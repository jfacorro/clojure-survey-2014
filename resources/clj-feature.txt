" Greater parity between Clojure and ClojureScript."
""lite" mode for quicker startup - I would be able to write Android apps with Clojure then"
""production" build, to optionally trade some dynamism for performance and startup time"
"'the environment as a value': https://groups.google.com/forum/#!topic/clojure-dev/S8BawG7nzJA"
"() instead of [], () instead of {}."
"(Homoiconic) markup for doc metadata"
"(debug :level ...)"
"(map Math/abs [1 2 -1])"
"(optional) static typing"
"-"
"-"
"/"
":let clauses supported in cond, like in for"
"?"
"?"
"A clojure.core function that returns clojure.lang.PersistentQueue/EMPTY"
"A debugger! Maybe this counts as a tool and not exactly a feature, but since there is no good debugger out there, I assume the language/compiler would have to be changed somehow to allow that."
"A faster mechanism for dispatch on multiple JVM types (multimethods ain't it!)"
"A golang compiler backend, with interop. Primarily for runtime performance and low overhead."
"A namespace lexical scope"
"A native Clojure profiler."
"A specification for alternative implementations of clojure"
"A threading macro (like ->, ->> and friends) that deals more gracefully with inserting arguments at specific places."
"A well supported mechanism to share source between Clojurescript and Clojure (cljx is difficult with Emacs + Cider)"
"Ability to generate code as optimized as if written in the native languages of the host environment, using inference instead of annotations."
"Ability to pause or stop the REPL."
"Ability to propagate exceptions between threads on deref"
"Adopt core.typed in core clojure code, support it, encourage the use of it"
"An actor system"
"An efficient domap: Like doseq, but with the ability to iterate over multiple parallel sequences as map does."
"An enhanced cljs-repl (or middleware) to make the development experience for Clojurescript as smooth as on the JVM"
"An open read table."
"Automatic pre/post condition support for core.typed ^:no-check"
"Automatic static type hinting / improved static code analysis"
"Automatic tail call optimisation"
"Bake the current alpha stuff in."
"Better GUI Programming, Better auth for web app"
"Better and simpler exception handling in multithreaded processes."
"Better beginner resources"
"Better communication of errors. "
"Better compiler error messages."
"Better compiler error reporting (supported by better assertions)"
"Better compiler warnings as an option. "
"Better core.typed and prismatic/Schema integration with core.typed"
"Better debugging"
"Better debugging like Racket"
"Better documentation tooling built into the language."
"Better error messages"
"Better error messages"
"Better error messages, both compile and runtime."
"Better error messages."
"Better error messaging"
"Better errors"
"Better errors from the compiler"
"Better exceptions and error messages"
"Better facilities for deterministic dataflow. "
"Better integrated pattern matching"
"Better multimethods"
"Better namespace tools."
"Better native try/catch (something like Slingshot but built right into Clojure)"
"Better stack traces"
"Better stack traces"
"Better start up time"
"Better syntax for commenting out (multi-line) code"
"Better tools for debugging, especially debugging laziness (ie. it should be lazy, why is it running out of memory?)"
"Better traces"
"Built-in database like datascript/datomic with great destructuring facilities so I don't need to keep using huge, nested maps."
"Built-in optional types"
"Built-in type inference and checking"
"Builtin cljx or equivalent"
"Builtin debugger."
"C Interop"
"CinC"
"Clojure deserves significant effort in how it reports errors and exceptions"
"Clojure in Clojure"
"Clojure in Clojure (not a language feature, but it's not like I'm going to say "dependent types" with a straight face)"
"Clojure on Clojure"
"Code analysis via the compiler"
"Common Lisp Style conditions"
"Common Lisp style error handling"
"Common Lisp-ish condition system"
"Common-Lisp-style condition system (i.e. handler-bind, restarts, catch/throw)."
"Compile directly to machine code for x86_64 Linux (LLVM?).  Sure, needs a GC and data structures, but this would be a *huge* win!  Would really compete with Go, for instance."
"Compile-time type checking"
"Compiler based on t.a.j will help foster creativity"
"Compiler flag to disallow nils/Nulls"
"Concatenative pipeline, like Gershwin (http://gershwinlang.org)"
"Concurrency features for updating/hotswapping vars in a given ns"
"Core.matrix integrated properly into clojure main"
"Cross-compilation (clj, cljs) support in the core language, e.g. feature expressions"
"Custom reader macros"
"Debugger support (jdi a support maybe  ?)"
"Dependent Types."
"Diamond wand threading macro"
"Disposable seqs (C#'s IEnumerable is disposable, which makes things nicer)"
"Docs docs docs docs docs"
"Documentation"
"Duck-typing inspections to warn if you do something completely nonsensical, without having to manually define or annotate any types or interfaces."
"Dynamic interop"
"Dynamic variables which play well with laziness (i.e. constructs like "for" which capture dynamic variable bindings)"
"Easier handling of non-double or long primitives. (Specifically floats!)"
"Easy default protocol implementation"
"Elevate core.logic to core language feature, accelerate work"
"Error-handling alternatives to throwing/catching exceptions."
"Exceptions"
"Extend Protocols to Other Protocols"
"Extensive debugging"
"Extremely loose declarative typing system. Schema, but backed in. Also better propagation of types (for interop) in that system."
"Extremely optional typing system (basically only for documentation purposes (like schema))"
"Fast Pattern Matching"
"Fast startup time"
"Fast startup!!"
"Fast tuples"
"Faster REPL startup and JVM startup"
"Faster startup"
"Faster startup"
"Faster startup"
"Faster startup"
"Faster startup (self hosting?)"
"Faster startup time"
"Faster startup time"
"Faster startup time."
"Feature Expressions"
"Feature Expressions"
"Feature expressions"
"Feature expressions"
"Feature expressions"
"Feature expressions"
"Feature expressions"
"Feature expressions / conditional compilation"
"Feature flags for runtime target (Cljx)"
"Feature tags"
"First class REPL support"
"First class continuations"
"First class macros"
"First class namespaces"
"First-class support for gradual typing a la core.typed"
"Fix stacktraces"
"Friendlier error messages"
"Friendly stack dumps"
"Fully supported and documented standard library. I thought contrib was the right way to go."
"Garbage collection delays solution. "
"Generic support and runtime performance gains from core.typed"
"Generics for core.typed.  (Yes, I know this isn't happening, and why, but I'd like it. :))"
"Github issues+pull requests for the contrib process"
"Haskell Arrows"
"Haskell pattern matching"
"Haskell type system :>"
"Helpful error messages."
"Heredocs"
"Higher-level abstractions for core async"
"Human readable exceptions"
"I can't"
"I don't know"
"I don't know at this moment"
"I don't know yet I am still figuring stuff out."
"I don't really miss anything. Keep simplifying the language!"
"I have no idea."
"I'd love for Clojure to lose it's dependency on a vm and be a standalone language."
"I'm good, thanks :)"
"I'm happy. Adding features isn't the be all and end all. More speed. Ideally clojure in clojure so optimisations are more accessible. Death to Compiler.java:-)"
"IDE "
"Illuminated macros"
"Immutable atomic namespaces"
"Improved performance for functions using primitive types."
"Improved startup time"
"Increased/Stricter Purity"
"Intention implying parens"
"LLVM / Clojure on Clojure"
"LLVM backend"
"Language support for channels"
"Lazy evaluation of non-sequence functions a la Haskell"
"Lean compilation"
"Less verbose way to express mandatory keyword arguments. ie [& {:keys [(not-nil foo bar bash)]}]"
"Like we made IAtom for Atom, I want this for all classes like MultiFn."
"Loading multiple versions of a namespace into same app"
"M-Expressions. Please think about the environment! We are burning our parentheses-reserves without thinking about our children!"
"ML"
"Make anonymous functions and closures inspect-able. We should be able to see the code of an anonymous function and the local var names and values that were in scope when it was created."
"Make core clojure smaller. remove agents, STM"
"More Clojure-centric error messages/exceptions"
"More aggressive error semantics around using functions that assume associative data structures with non-associative data structures (e.g., (contains? 2 :foo) vs. (get 2 :foo))"
"More extensible reader/reader macros"
"More extensive documentation"
"More flexibility regarding circular dependencies, i.e. same-namespace file loading (I hear it is possible but I found it confusing / undocumented)"
"More hosts (iOS, better android)"
"More informative stack traces on exceptions."
"More module namespaces."
"More support for core.typed"
"More useful/readable stacktraces"
"More work on typed clojure"
"Multidimensional arrays"
"Mutability (seriously)"
"My experience has always been that features are added before I even know that I was missing them, like core.async. Can't think of anything!"
"Nah. It's perfect as is."
"Name *one* language feature you would like to see added to Clojure?"
"Namespaces as values"
"Native host"
"Newspeak-like module system"
"Nicer stack traces"
"No AOT ripple"
"No global state in the Clojure Runtime (clojure.lang.RT, c.l.Namespace, etc)"
"None"
"None, stop adding stuff"
"None. Keep it small."
"Not a feature, but more widespread usage/jobs"
"Not a feature, but startup performance improved for Android development"
"Not language per-se, but:  a native (LLVM?) compiler"
"Not missing anything yet!"
"Nothing"
"Official support for Android"
"Official support for more hosts (like the Erlang VM)."
"One? Abstractly, I'd like greater compatablility with Racket."
"Optimized compile mode that traded dynamic development environment for faster performance.  e.g.  "Inline" var functions."
"Optional Typing"
"Optional static typing"
"Optional static typing (like Groovy)"
"Optional static typying"
"Package manager not unlike NPM"
"Parallel transducers"
"Parsing, Instaparse is great, but it seems slow."
"Pattern matching"
"Pattern matching"
"Pattern matching"
"Pattern matching/destructuring combination"
"Please add more RNG / math stuff to the standard library"
"Pmap-style concurrency improvements"
"Pods"
"Powerful error handling mechanism (a la CL restarts)"
"Predicate Dispatch"
"Predicate dispatch"
"Production mode with minimal startup time"
"Proper reader literals would be awesome"
"Protocols for internal interfaces as per ClojureScript."
"Protocols that don't break reloading; a second refinement of some kind of compile-time "assert that I obey this contract" without types somehow."
"Racket style documentation"
"Racket's reader extension"
"Racket-style "for" iteration macros, featuring automatic type hints."
"Reader macros"
"Removal of the JVM / Dialekt that is hosted  on Posix/C"
"Resource Scopes or something similar, that behave well with laziness (if its even possible)"
"Rich Hickey's hair"
"Run on mobile phones"
"Run simple "scripts" without the need for all the namespace/project structure ceremony."
"Self-hosting ClojureScript"
"Sensible stacktraces"
"Signals/Conditions"
"Something similar to defadvice in Emacs Lisp or add-hook from the lib Robert Hooke (the lib doesn't work with Clojurescript)"
"Static compilation of java methods - would probably give much speed."
"Static type checking"
"Static type checking"
"Static type system"
"Static types"
"Static typing"
"Static typing"
"Static typing"
"Static typing"
"Static typing (core.typed which is simple to use)"
"Static typing (maybe core.typed) as part of Clojure - would be useful for large projects"
"Static typing à la Haskell (core.typed should win)"
"Strong built-in stacktrace support"
"Sum types"
"Support for Generators/Coroutines"
"Support for Java varargs"
"Support for complex matrices in core.matrix."
"Support for primitive functions with more than 4 (up to the jvm limit many) parameters including int and float"
"Support of core.async in compiler (Rich was musing about it after his talk on EuroClojure)"
"Swift host"
"TCO"
"TCO"
"TCO "
"Tail Call Optimization"
"Tail call elimination (I know, I'm hoping it's in Java 9)"
"Tail call optimization"
"Tail call optimization (come on Java!)"
"Tail-call optimization, if and when the jvm will allow it"
"Target Erland/BEAM runtime"
"Tco"
"The compiler shouldn't throw stacktraces when there's a syntax error"
"The option to have better error messages for core macros, like what illuminated macros or seqex could provide, even if it hurts performance."
"Tooling, specifically stepping, breakpoints in IDE"
"Transactional namespaces"
"Type"
"Type data schemas"
"Type system, though this is very difficult and there are some existing solutions."
"Typed clojure"
"Types"
"Types"
"Types"
"Types"
"Types"
"Types"
"Types"
"Types (and not as an add on library) "
"Types!"
"Unification of support on all platforms Java, .NET and javaScript"
"Useful stacktraces."
"Utility functions like has-key? for maps by default"
"Verbose function names - no more conj, but conjoin, etc. And encourage community to write verbose functions names. They would fix cognitive leaks I am experiencing while reading code."
"Vulcan mind meld so I can get my non-receptive (read 'bull-headed and myopic') colleagues to see the beauty of Clojure"
"Whatever Rich thinks is a good idea."
"Will leave that to Rich :)"
"a Clojure implementation of how to read in files (none of this mucking about in Java)."
"a better debugging"
"a debugger"
"a more approached clojure.typed. A cross between schema and core.typed."
"ability to "script" with just one .clj file (including dependency declarations & sourcecode)"
"ability to develop for native mobile"
"ability to perform meaningul linting statically"
"actors"
"adding more functions in the spirit of "update": mapvals for instance."
"advanced static typing"
"algebraic data types with compiler bailing on non-exhaustive pattern match"
"allow any function to be mocked"
"anti source to sync bug miracle"
"async io support"
"automated namespace refactoring"
"being able to use multimethod implementations without explicitly requiring their ns"
"better assert mactos"
"better built-in testing framework with more descriptive failures"
"better clojure code introspection"
"better clojure/clojurescript unification (so we can have official support of test.check for cljs, for example)"
"better compiler error reporting and debugging"
"better debugging support"
"better error handling"
"better error messages"
"better error messages/stack traces, especially for the go macro in core.async"
"better error reporting"
"better facilities for writing functions & macros with default / keyword args"
"better namespaces"
"better primitive support (e.g. on protocols)"
"better resource handling (sockets, files, etc)"
"better stack trace error messages"
"better stack traces"
"better start up time"
"broader support of reducibles in core fns"
"built-in async IO, maybe in core.async"
"call/cc"
"clean stacktraces "
"cljx as part of the language would probably mean faster and better interop with other clojure tools"
"cljx/feature expressions"
"clojure in clojure"
"clojuredoc"
"common lisp condition system"
"common lisp style restarts"
"compiler in clojure"
"compiler optimizations based on core.typed to encourage library developers to add type signatures"
"compiler to native code"
"composable namespaces"
"condition and restarts system similar to Common Lisp (with restartable frames in the debugger)"
"continuations"
"continued improvements in primitive support"
"core support for pattern matching"
"core.async as a full, first-class language feature, rather than a macro. It's incredibly tedious and error-prone relative to goroutines."
"core.async as lang feature (go like)"
"core.typed"
"core.typed builtin, matured and widely supported"
"could transducers support unboxed primitive args?"
"currying"
"datomic/datalog query language in core"
"debugger"
"debugger"
"debugger"
"debugger"
"debugging capabilities"
"decorators (as a field in the metadata map for defn, like :pre and :post)"
"dependent types"
"dependent types"
"deprecate wrong docs"
"dissoc-in"
"dissoc-in !!"
"documentation"
"documentation on gotchas within advanced compilation with cljs"
"dunno. still learning the existing ones"
"easier and shorter syntax for the equivalent of Java-annotations"
"easier debugging"
"easy steps to make code faster"
"easy to use, targeted hosting & build services"
"environment as a value"
"erlang"
"erlang"
"erlang like test coverage"
"fast start time"
"fast startup"
"fast startup"
"fast startup"
"fast startup"
"fast startup"
"fast startup time"
"fast startup time"
"fast startup time"
"faster startup"
"faster startup"
"faster startup time"
"feature expressions"
"feature expressions"
"feature expressions"
"feature expressions"
"feature expressions"
"feature expressions"
"feature expressions"
"feature expressions"
"feature expressions"
"feature expressions"
"feature expressions "
"feature expressions so that cljx isn't necessary any more"
"first class environments"
"first class namespaces"
"first-order queues with literal reader syntax (e.g., #[])"
"functional network sockets"
"generators"
"generic vector-of"
"gradual typing"
"green threads"
"hot swappable code"
"ide and debug tools as good or better than java will make clojure adoption better"
"immutable namespaces"
"immutable namespaces"
"improve compiler error messages when macros are involved!"
"improve startup time for java and android"
"improved start-up time"
"in line debugger ala pdb from python. "
"infix notation"
"int support without marshalling through longs... arrays are still indexed by integers... so ints are important"
"interactive debugger"
"interactive stacktrace"
"joinads"
"lean runtime"
"let, cond, etc with more parentheses/brackets — to improve readability and so that I can swap the order of bindings/clauses with a single key chord in Emacs."
"lib-clojure"
"linting pls"
"llvm backend"
"llvm backend"
"llvm based backend"
"location transparency ala Erlang, but I'm stretching"
"low level jvm-free, llvm-free, x86_64 output"
"magic distributed programming that "just works" :) I might be asking too much! LOL"
"makes stack trace less noisy"
"map-vals"
"modules"
"modules"
"modules, I think. More focused on using what is there"
"more compile-time checks (core.typed needs more work/support)"
"most things are already addressed by libraries (core.async core.logic, error conditions/restarts) "
"multi-pass compilation"
"n/a"
"n/a"
"named loops with recur-to"
"native execution"
"nicer stacktraces"
"nil"
"no JVM!"
"none"
"none"
"none"
"not the language, distributed core.async "
"not-nil?"
"numerics"
"object like common lisp, with a metaobject protocol"
"optional static typing"
"optional static typing (ala typed clojure)"
"optional types"
"optional typing"
"optional typing, maybe?"
"ordered-map (a true array-map, not a half-internal flimsy structure that is now)"
"parameterized namespaces"
"pattern matching"
"pattern matching"
"pattern matching"
"pattern matching"
"pattern matching"
"pattern matching as core to the langauge"
"pattern matching on functions"
"pattern matching on functions"
"performance"
"predicate dispatch"
"predicate dispatch"
"primitive collections"
"private functions in clojurescript"
"production rules"
"racket-style macro system."
"reactive extensions aka "observables""
"reader and evaluation the same -- which means clojure grammar"
"reader macros"
"reader macros"
"reify/deftype like forms allowing abstract class extension."
"resource management/scopes"
"resource-scoped streams; composable abstractions for working with streaming data which doesn't fit in memory, and which is associated with a resource lifespan."
"resumable functions"
"richer error handling, maybe a la Common Lisp conditions"
"run code from a single file like "python main.py""
"runtime / reflective access to the compiler"
"scripting"
"see comment below"
"self-hosted clojurescript"
"self-hosted or Clojure on SBCL :)"
"slingshot"
"socket support for core.async"
"something like generators (the ability to yield several values, and compose these things easily)"
"speed "
"static compilation of vars (a la Oxcart/Skummet)"
"static method invocations instead of vars - runtime performance"
"static type checking / better error reporting for type errors"
"static type driven optimisation"
"static types"
"static types"
"static types (typed Clojure)"
"static typing"
"stepper / debugger"
"string interpolation"
"stripped down deploy package (tree shaking, removing eval)"
"sum types"
"supervisors"
"tail call optimization"
"tail call optimization"
"tail recursion"
"target llvm"
"targeting LLVM or C runtime"
"time"
"tree shaking"
"two-pass compile cycle, for ditching (declare)"
"type"
"type checking"
"type checking"
"type checking"
"type inference"
"type inference"
"type inference for typed clojure"
"type system"
"type-annotated libraries"
"typed clojure"
"types check, something a little more "professional" of core.type that I don't find mature enough"
"typing"
"unencoded binary data literals via custom delimiters a la mime/multipart"
"versioned namespaces"
"visual programming (à la Max/MSP using channels)"